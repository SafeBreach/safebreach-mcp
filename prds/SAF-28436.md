# SAF-28436: Expose Graceful Shutdown on SafeBreachMCPBase

## Overview

- **Task Type**: Enhancement (API contract)
- **Purpose**: Allow external process managers (mcp-proxy) to request graceful server shutdown
  without resorting to asyncio task cancellation, which orphans uvicorn's listening socket.
- **Target Consumer**: mcp-proxy (SIMP)
- **Originating Request**: SAF-28436 — discovered during feature flag polling restart implementation

## Problem

`SafeBreachMCPBase.run_server()` creates a `uvicorn.Server` locally and immediately `await`s
`server.serve()`. There is no way for an external caller to reach the server instance.

When mcp-proxy needs to restart an MCP server (e.g., after a feature flag change), the only
option is `task.cancel()`. This delivers `CancelledError` into uvicorn's `serve()` → `_serve()`
flow, but uvicorn's internal `asyncio.Server` objects (which hold the listening socket) are never
told to `close()`. The port stays bound, and the restart fails because the new server cannot bind.

Setting `uvicorn.Server.should_exit = True` triggers uvicorn's natural exit path:
`main_loop()` exits → `shutdown()` runs → socket is closed. But the caller needs a reference
to the server object to set this flag.

## Solution

Expose the `uvicorn.Server` reference and provide a `request_shutdown()` method on
`SafeBreachMCPBase`.

### Changes to `safebreach_mcp_core/safebreach_base.py`

**1. Add instance attribute in `__init__`:**

```python
self._uvicorn_server: Optional[Any] = None
```

**2. Store the reference in `run_server()`, after creating the server (around line 164):**

```python
config = uvicorn.Config(app=app, host=bind_host, port=port, log_level="info")
server = uvicorn.Server(config)
self._uvicorn_server = server  # <-- ADD THIS LINE
try:
    await server.serve()
finally:
    cleanup_task.cancel()
    monitoring_task.cancel()
    self._uvicorn_server = None  # <-- ADD THIS LINE
```

**3. Add a `request_shutdown()` method:**

```python
def request_shutdown(self):
    """Signal the uvicorn server to exit gracefully.

    This causes uvicorn to exit its main_loop, run its shutdown sequence
    (which closes the listening socket), and return from serve().
    Safe to call even if the server is not running.
    """
    if self._uvicorn_server is not None:
        self._uvicorn_server.should_exit = True
```

### That's it — 3 additions, no changes to existing logic.

## How mcp-proxy Will Use This

```python
# Before cancelling a server task for restart:
server_instance = self.server_instances[server_id]
server_instance.request_shutdown()  # uvicorn exits cleanly, port released
await task  # task finishes naturally
# Port is now free — start new server
```

## Testing

- Unit test: call `request_shutdown()` when `_uvicorn_server` is None — should be a no-op
- Unit test: call `request_shutdown()` when `_uvicorn_server` is set — should set `should_exit = True`
- Integration (mcp-proxy side): verify port is released after `request_shutdown()` + task await

## Definition of Done

- [ ] `_uvicorn_server` attribute added to `__init__`
- [ ] `_uvicorn_server` stored in `run_server()` before `serve()`, cleared in `finally`
- [ ] `request_shutdown()` method added to `SafeBreachMCPBase`
- [ ] Existing tests still pass
- [ ] New unit tests for `request_shutdown()`
